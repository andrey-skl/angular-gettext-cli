#!/usr/bin/env node
'use strict';

var glob = require("glob");
var fs = require('fs');
var argv = require('minimist')(process.argv.slice(2));
var Extractor = require('angular-gettext-tools').Extractor;
var Compiler = require('angular-gettext-tools').Compiler;

if (!argv.dest) {
  throw new Error('dest parameter missed');
}

if (argv.compile) {
    compile(argv);
} else {
    extract(argv);
}

function strToArray(obj, key, value) {
    obj[key] = obj[key].replace(/\s/g,'').split(",");
}

// add obj['markerName'] = obj['marker-name'] etc.
function objToUpperCase(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i].replace(/-(.)/g, function (m, $1) {
            return $1.toUpperCase();
        });

        obj[key] = obj[keys[i]];
    }

    obj.markerNames && strToArray(obj, 'markerNames');
    obj.attributes && strToArray(obj, 'attributes');

    return obj;
}

function expandFileNames(options) {
    var globFileNames;
    if (options.files)
        globFileNames = glob.sync(options.files, options.exclude ? { ignore: options.exclude } : null);
    else
        globFileNames = [];
    var positionalFileNames = options._;
    // Still need to expand @filename -> read content of filename
    var expandedAt = [];
    function add(filename) {
        if (filename)  // ignore empty strings
            expandedAt.push(filename);
    }
    for (let i = 0; i < positionalFileNames.length; i++) {
        let fileName = positionalFileNames[i];
        if (fileName[0] !== '@') {
            // filename does not start with @
            add(fileName);
        } else {
            // filename starts with @, read content
            let content = fs.readFileSync(fileName.substr(1), options.encoding || 'utf-8').split(/\s+/);
            for (let j = 0; j < content.length; j++)
                add(content[j]);
        }
    }
    return globFileNames.concat(expandedAt);
}

function compile(options) {
    var gettextCompiler = new Compiler(objToUpperCase(options));

    var fileNames = expandFileNames(options);
    if (options.format && !Compiler.hasFormat(options.format)) {
        throw new Error('There is no "' + options.format + '" output format.');
    }

    var output = gettextCompiler.convertPo(fileNames.map(function(fileName) {
        return fs.readFileSync(fileName, options.encoding || 'utf-8');
    }));

    console.log('Finished compiling, read '+fileNames.length+' files.');
    fs.writeFileSync(options.dest, output, null);
    console.log('All files processed, stored in a file ' + options.dest);
}

function extract(options) {
    var gettextExtractor = new Extractor(objToUpperCase(options));

    var fileNames = expandFileNames(options);
    fileNames.forEach(function (filename) {
        var content = fs.readFileSync(filename, 'utf8');
        gettextExtractor.parse(filename, content);
    });

    console.log('Finished parsing, read '+fileNames.length+' files.');
    fs.writeFileSync(options.dest, gettextExtractor.toString(), null);
    console.log('All files processed, stored in a file ' + options.dest);
}
